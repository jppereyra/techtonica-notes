Today was my first day as a mentor with the Techtonica team, and I know it was a proper _first day_ because I was feeling both excited and terrified; excited because I deeply enjoy playing around with computers and helping others learn, terrified because _"what if I'm not good enough?"_ which leads me to the first topic of my first post here.

### Impostor Syndrome

> "...a psychological experience in which a person suffers from feelings of intellectual and/or professional fraudulence." â€” [Wikipedia](https://en.wikipedia.org/wiki/Impostor_syndrome)

Sometimes, when I'm trying to learn something new or I'm practicing a new skill it's easy for me to loose perspective; I tend to get lost in the weeds and as the setbacks of the learning process pile up it's easy to feel demoralized. To makes things harder,  if I'm trying to do this on a deadline and in an environment where everyone else is also giving their best, an old friend tends to show up: impostor syndrome.

It is a feeling that makes me think: _"maybe this is it, maybe I'm not good enough for this particular challenge_". Even as I write these words I wonder _"is this the right way to approach this subject? maybe let someone else bring it up, I am not a good writer".

But I continue regardless, because if you have ever feel like this I want you to know that you are not alone, and it does get easier over time. I'm sure you can look at what you have accomplished so far and conclude that you have done hard things. If you are running code, any code, you have already accomplished something that most non-technical people have no clue about, you should be proud.

As you continue on this journey, you will have more and more stories you can refer back to that show you that, far from being an impostor, you are someone who dared and who achieved, who accomplished something hard, who can tackle hard problems and maybe not always succeed right away, but always learn from it.

So yeah, this may not be the best written post, but I wrote it :). Now, onto more technical things.

### Recursion is Hard

**ðŸ›‘ Spoilers Ahead**: This topic doesn't appear on the Techtonica curriculum until [week 7](https://github.com/Techtonica/curriculum/blob/main/README.md#week-7---Advanced-JS-and-React). It is only mentioned on this post because someone said to me _"recursion is hard"_. So, if you know what recursion is and also think it's hard, read on, otherwise you might want to wait until the topic is formally introduced.

If you're still with me, let's see... what's up with this recursion thing:

```javascript
function factorial(n) {  
  if (n === 0) return 1; // base case
  return n * factorial(n - 1);
}
```

One defines a base case, a recursive step, and done! Easy enough, right? Not quite, I think. Recursion is often taught as an alternative to looping in the context of an [imperative programming](https://en.wikipedia.org/wiki/Imperative_programming) language as a way to simplify the code. Let's see what the `factorial()` function looks like written in a more imperative way:

```javascript
function factorial(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

So, it's not much worse in terms of style and if you're already comfortable with `for` loops and variables, it may feel much more comfortable. So, if you are still curious about recursion, let me tell you the story of recursion the way I learned it when I was in college...

_**Disclaimer**
Please note that in the preceding examples, in an effort to keep the code simple, I omitted checking the function's input parameters. In your code you should check your input params, in this case you could have used something like:_

```javascript
if (!Number.isInteger(n) || n < 0) { // 
    throw new Error('Invalid argument: "n" must be a non-negative integer.');
}
```

Ok, on with the storytelling: in a land far, far away... in a forgotten time (?) there was a programming language known as Haskell.

Haskell did not have loops of any kind, nor it had any variables (in the traditional sense) or instructions/statements. But, you say, how are you supposed to program without loops, variables and instructions?? (I can hear the outrage).

The answer is: functions. Haskell gives you:

* Functions.
* Constants (immutable variables, i.e. once you do `x = 5`, you can't assign `x` any other value).
* A few other things we're not going to get into here.

So, if all you have are functions, then recursion all of the sudden becomes your best friend! Let's look at `factorial()` in Haskell. The syntax will look a bit weird, but worry not, it's actually pretty easy to understand:

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

The way to read this in plain English is: 

Line 1: _"There is a function `factorial` which takes an `Integer` as its only parameter and returns another `Integer`"_.
Line 2: _"When `factorial 0` gets called somewhere, return 1"_.
Line 3: _"When `factorial n` gets called, take `n`, multiply it by the result of `factorial(n-1)` and return that."_

If you think this is more similar to a mathematical definition than a computer program, you are correct! Haskell is what is known as a [declarative programming](https://en.wikipedia.org/wiki/Declarative_programming) language (and, in particular, a [functional programming](https://en.wikipedia.org/wiki/Functional_programming) language) . In this world you describe the relationships between the operations and *not the control flow*. The language itself will figure out how to produce the desired result.

You may still be wondering **how** this detour into the declarative programming rabbit hole will help you understand recursion better. In my humble opinion, for recursion to make sense you have to forget that you are in the imperative paradigm and imagine you are in the declarative realm, where all operations are defined _as functions_ of other operations.

In every recursive function you need a _base case_, which is the basic fact or state from which all other cases can be derived, and we usually write that first, probably to avoid forgetting about it (we forget, we get infinite recursion and bad things happen).

This type of programming generally shines when dealing with repetitive patterns or structures, for example lists and trees.

Recursion has all sorts of problems when used in imperative languages, but it is usually taught that way because of their popularity, and because people don't have the time to learn an entirely new programming language.

However, many popular programming languages are a confused mess of features (ahem, JavaScript...)  taken from other languages, for example:

```javascript
[1, 2, 3].map(x => x * 2);
```

written in Haskell...
 
```haskell
map (\x -> 2 * x) [1, 2, 3]
```

See any similarities?

In fact, I believe a good chunk of the success of JavaScript is due to their adoption of functional programming features, but I digress.

To come back to my earlier point, learning about recursion using an imperative language feels like doing it the hard way, and even though it may be quicker in the short term, the long-term learning suffers. After spending some time with a purely functional language like Haskell you begin to internalize that, in writing code this way, you are describing the behavior of data structures in a very elegant way, but letting go of the illusion of control provided by `for`s, `if`s, etc. can be really hard at the beginning.

I will leave this topic here for now, and maybe pick it back up if folks are interested in it. There is also a fascinating rabbit hole to explore in how recursion works under the hood and it's effects on memory management.

Making a choice between imperative and declarative programming, is also a choice of coding style and specifically of code structure, which leads us to the next topic...

### Well Organized Code is Better

Better for you, the programmer, and anyone else that is going to read it afterwards. Entire books have been written on this subject, so I will focus on just one example. Take the following problem:

> **Return Largest Numbers in Arrays**
> Return an array consisting of the largest number from each provided sub-array. For simplicity, the provided array will contain exactly 4 sub-arrays. [Read the full problem here](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-algorithm-scripting/return-largest-numbers-in-arrays)

#### Solution A
```javascript
function largestItem(arr) {
  let max = arr[0];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
  }
  return max;
}

function largestOfFour(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(largestItem(arr[i]));
  }
  return result;
}
```

#### Solution B
```javascript
function largestOfFour(arr) {  
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    let max = arr[i][0];
	for (let j = 0; j < arr[i].length; j++) {
	  if (arr[i][j] > max) max = arr[i][j];
	}
	result.push(max);
  }
  return result;
}
```

In solution A we first break down the problem in two areas:
1. How to find the largest number in an array.
2. How to make a new array with the numbers we found in (1).

This helps us manage the scope of the problem we focus on at any given time.

In solution B we tackle the whole problem in one go, resulting in common issues such as:
1. Which `for` loop does what? it's hard to see at a glance.
2. Should `max` be initialized inside or outside the first loop?
3. Keeping your indices `i` and `j` where they need to be can be hard and error prone.
4. You can't easily re-use the logic to find the largest number for other problems.

My argument here is that thinking about structuring your code is also part of breaking down the problem in manageable chunks, and vice-versa. You're likely to spend less time trying to figure out what your code is doing if you spend a bit of time thinking about structure up front.

And even if you don't come up with a good structure that fits your problem up front, you can always make it better later, we even have a word for it: [Refactoring](https://en.wikipedia.org/wiki/Code_refactoring) and some [famous programmers wrote books](https://martinfowler.com/books/refactoring.html) about it :).

That's it for today, I hope you found this useful, and in any case I would greatly appreciate your feedback! Feel free to dm me with any comments, questions or corrections.
