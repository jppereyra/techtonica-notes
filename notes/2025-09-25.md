
In today's edition we have tips for effective pair programming, thoughts on how to communicate and think about algorithms and a reflection on how to approach the art of programming.

Have you ever heard of the Marshmallow Challenge? If not, please google it up! It's a challenge often used as a STEM team-building exercise where teams are given a handful of spaghetti (about 20 or so), some masking tape, scissors and one marshmallow. The challenge is to build the tallest tower possible with the marshmallow at the top of the tower. It makes for a fun game night with friends, too IMHO.

I bring this up because the story goes that 4th graders consistently beat rocket scientists and engineers at the challenge. While structured adult engineers want to devise the best possible structure, the kids are pure chaos and madness and through trial and error come up with some amazing designs.

If chaos works for you and gets you the results you want, go for it! In the following sections I will suggest some ways to organize your work, but by no means I intend to get in the way of creativity, tinkering and chaos. A lot of the technical things I learned, I did by trial and error, and in many instances the "magic smoke" escaped from the device I was working with; although frustrated at the time, I learned a ton and also had fun in the long term.

But, if you are not having fun, or are feeling frustrated, some of the tips coming up may help.

### Pair Programming

Pair programming is an instance of something that us humans do all the time: work together to solve a problem. As such it can be as chaotic or neatly organized as the humans involved want.

Pair programming is a _practice_ (pretty much like coding as a whole) which means it needs to be _practiced_, honed, refined. If you jump right in without much practice it _may_ feel awkward. So, let's review the aspects to be practiced:

Being _The Driver_: This person controls the keyboard and mouse, writing the code and focusing on the specific syntax and implementation. In this role you are actively trying to get the computer to do the thing you and your partner want. You are responsible for writing readable, elegant code.

Being _The Navigator_: This person watches the code being written, thinks about the bigger picture (design, architecture, edge cases), asks questions, and guides the driver. By definition you (generally) should not be worrying about code syntax, APIs, etc. but rather thing about the problem and the design of the solution, trying to identify "gotchas", testing assumptions, etc.

Both roles carry their own responsibilities, require focus and dedication. If you ever _driving_ and feel like you are doing too many things (coding, thinking about edge cases, the problem, etc.) talk to your partner and make sure they are _navigating_ for you; and vice versa, when you are navigating, make sure you're taking a step back, but remain focused on the problem and the solution.

Then, switch roles often. In a real scenario you may not switch roles for the entire session, but in this case you are _practicing_, so while you may be a tad less efficient by switching many times, you will be learning and getting more comfortable in each role.

Another aspect to have in mind is how learning works. With two senior engineers working together and bringing their own perspectives we can expect that:

> A system with two programmers possesses greater potential for the generation of more
>  diverse solutions to problems for three reasons:
>
> 1. the programmers bring different prior experiences to the task;
> 2. they may assess information relevant to the task in different ways;
> 3. they stand in different relationships to the problem by their functional roles.
> 
> In an attempt to share goals and plans, the programmers must overtly negotiate a shared course of action when a conflict arises between them. In doing so, they consider a larger number of ways of solving the problem than a single programmer alone might do. This significantly improves the design quality of the program as it reduces the chances of selecting a poor method. — [Source](https://en.wikipedia.org/wiki/Pair_programming#Design_quality)

Note that we are not talking about one programmer learning from the other one, or letting them solve the problem entirely. If you ever find yourself driving the whole solution, or your partner doing so, it's a good time to stop and reassess your roles.

It is entirely normal, in a learning setting, that one person may have a deeper knowledge that the other in an area or programming language; that is fine, it takes discipline to _practice_ pair programming and make sure both you and your partner are getting the benefits of designing a better solution and learning together.

So, if the fray of the moment as you are tackling that difficult problem together, take a moment to be mindful about the _practice_ of pair programming, discuss roles, adjust as necessary, and switch often.

### Drawing Stuff

I vividly remember the day of my first job interview. My first conversation was with someone in recruiting, which I had assumed was a programmer but when I was about 10-15 minutes deep in technical jargon, I noticed they were... confused. Anyways, that day, after 3-4 30 minutes conversations with various people in the company I got presented with a test... a set of 10 or so questions printed on a sheet of paper, and a stack of blank printer paper to write my answers on, I was both baffled and excited. The questions ranged from the purely theoretical (e.g. describe the main tenets of object oriented programming, pros and cons, etc.) to problems I had to code on paper. Since I had all the time I wanted, I wrote some 10-15 pages of stuff... poor soul who had to read through my handwriting.

We don't do interviews that way anymore, but almost all tech interviews today include a system design section that is conducted in front of a whiteboard or through an online "virtual" whiteboard. This medium allows us to express abstract concepts, communicate, analyze, "poke" at it, without a compiler or interpreter breathing down your neck. As far as I know, all software gets drawn and re-drawn many times before the first line of code is written.

But JP, stop! Are you advocating for a waterfall process? No, I'm not, definitely not. And if you don't know what I'm referring to with _waterfall_, don't worry, it's something that should have never existed.

You see, when you start working on a new problem, you have to understand it first, or at least start to understand it... start falling in love with said problem. Drawing boxes with text in them and arrows connecting those seems to be some sort of universal engineering language that we all gravitate to. Flow charts have been used since the dawn of computer science to describe algorithms. When you draw a flow chart, you are not only making something that will allow you to better communicate with others, but also will allow you to better communicate with yourself, as you work through the problem.

Pseudocode (i.e. text that resembles code but doesn't conform to a specific language syntax) serves a similar purpose, although I was never a big fan of using it, for no reason other than personal preference.

So, when you start working on a problem try drawing it up first, the problem and the solution. Before you shackle yourself to a specific language or syntax, allow yourself to explore options. In an interview setting you will be expected to analyze the pros and cons of different solutions; being able to quickly visualize those solutions will be a key skill that you will use for your entire career.

You can use whatever you want to draw, but if you want a recommendation, I like [Excalidraw](https://excalidraw.com/), it's free, simple and fun!

### Programming by Coincidence

> Suppose Fred is given a programming assignment. Fred types in some code, tries it, and it seems to work. Fred types in some more code, tries it, and it still seems to work. After several weeks of coding this way, the program suddenly stops working, and after hours of trying to fix it, he still doesn’t know why.
> 
> Fred may well spend a significant amount of time chasing this piece of code around without ever being able to fix it.  No matter what he does, it just doesn’t ever seem to work right. Fred doesn’t know why the code is failing because he didn’t know why it worked in the first place. It seemed to work, given the limited “testing” that Fred did, but that was just a coincidence. Buoyed by false confidence, Fred charged ahead into oblivion. Now, most intelligent people may know someone like Fred, but we know better. We don’t rely on coincidences—do we? — The Pragmatic Programmer: From Journeyman to Master, p. 173.

The Pragmatic Programmer is a great little book, that shares space in my shelves with some other, not so little, icons of my generation: Clean Code, Code Complete 2, etc.

I first learned about programming by coincidence from one of my mentors, Pablo Graña. Pablo was a brilliant architect who took an interest in shaping young, wild coders and showing them the path to become engineers. One time I was "just trying to get something to work" and he said the magic words: _"well, the problem is that you are coding by coincidence"._ Indeed I was.

That mental state where you are just trying to give the computer whatever it wants, just so that you programs does something that resembles working and you can rest your mind for a minute; that leads to coding by coincidence. It also may seem rewarding at first, but if you ask yourself _"do I understand why this works?"_ you may be quickly disappointed.

Now, there is a time to throw stuff at the wall and see what sticks; it is indeed part of the learning process, and it usually goes away as you start to understand the patterns of who things work inside the little black box. It is, however, useful to check yourself and make sure you dedicate time and effort to internalizing those learning, so that the next time around you can code more and more confidently. The wording that the authors of The Pragmatic Programmer use is _intentional programming_, the practice of programming with purpose and deliberate thought.

### Algorithms

I have been using the word _algorithm_ a bit loosely in my conversations lately, so I though I'd clarify a few things.

> The modern meaning for algorithm is quite similar to that of _recipe, process, method, technique, procedure, routine, rigmarole,_ except that the word "algorithm" connotes something just a little different. Besides merely being a finite set of rules that gives a sequence of operations for solving a specific type of problem, an algorithm has five important features: — The Art of Computer Programming, Volume 1, p. 4.

In summary, those 5 features are:

- Finiteness. It must always terminate after a finite number of steps. It can't run forever.
- Definiteness. Each step must be precisely defined; the actions to be carried out must be rigorously and unambiguously specified for each case.
- Input. It has zero or more inputs. Values may be given to the algorithm before it begins to use as an input.
- Output. It has at least one output, and said output or outputs will have a relation to the input.

These definitions are independent of all programming languages, and even from computing as a whole; they are fundamental in nature.

In addition to those 5 features, and algorithm will likely make use of intermediary calculated values, or variables. And a useful way to design and test an algorithm, is by running through an example. For instance, let's say I want to make an algorithm to calculate the factorial of a number, I may write something like:


```
name: factorial
inputs: n
outputs: result

n < 0 -> result is not defined
n = 0 -> result = 1
n > 0 -> result = factorial of (n-1)

description: I will multiply 1, 2, 3, 4... up to n and return it as a result.

define auxiliary variable: i

1: if n is < 0 return an error, as this is undefined
2: result = 1, i = 1
3: if n equals 0 return result and end execution here, otherwise continue
4: if i > n return result, otherwise continue
5: multiply result by i, store it in result
6: increment i by 1
7: go to line 4

test:

factorial of 5

1:  5 is not negative, so we continue
2:  result = 1, i = 1
3:  5 is greater than 0, so we continue
4:  i is 1 and 1 < 5, so we continue
5:  1 * 1 = 1, result = 1
6:  i = 2
7:  i is 2 and 2 < 5, so we continue
8:  1 * 2 = 2, result = 2
9:  i = 3
10: i is 3 and 3 < 5, so we continue
11: 2 * 3 = 6, result = 6
12: i = 4
13: i is 4 and 4 < 5, so we continue
14: 6 * 4 = 24, result = 24
15: i = 5
16: i is 5 and 5 = 5, so we continue
17: 24 * 5 = 120, result = 120
18: i = 6
19: i is 6, 6 > 5 so we stop execution and return result

result = 120

```

It might seem tedious at first, but the more you practice the quicker you'll get, picking up patterns along the way, going back and improving previous algorithms you build as well!

I see writing things down as a way to slow down the thinking process and being able to focus on the details, but everyone is different. I read somewhere that Nikola Tesla was known to devise entire machine designs in his head, and then build them directly; which is definitely not how it works for me.

Give a try!



